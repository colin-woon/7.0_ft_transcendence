# System Architecture

## 1. High-Level Design: Microservices (F)

We are adopting a **Microservices Architecture** to separate concerns and allow polyglot development.

* **Service A: Auth Service (Java/Quarkus)**
    * **Responsibility:** Identity Provider (IdP). Handles OAuth, mints JWTs, manages User DB.
    * **Security:** Asymmetric Key Management (Private Key held here).
* **Service B: Forum Service (Python/FastAPI)**
    * **Responsibility:** Business logic for posts, comments, votes.
    * **Auth:** Stateless verification of JWTs using Public Key.
* **Service C: Chat Service (Java/Quarkus)**
    * **Responsibility:** WebSocket handling, Message persistence, Friend logic.

## 2. Authentication & Authorization Flow

* **Protocol:** OAuth 2.0 + JWT (RS256 Signature).
* **Secret Management:**
    * **HashiCorp Vault: (?L)** Stores the RSA Private/Public keypair.
    * **Startup:** Services fetch the **Public Key** from Vault at boot and cache it.
* **The Flow:**
    1.  User logs in via Auth Service -> Receives `Access_Token` (15 min) & `Refresh_Token` (7 days).
    2.  User requests Forum/Chat -> Sends `Access_Token` in Header.
    3.  Forum/Chat verifies signature locally (Stateless) using cached Public Key.
    4.  **RBAC:** Role (STUDENT/ADMIN) is embedded in JWT Claims for instant permission checks at the service edge.

## 3. Communication Patterns

### A. Synchronous (REST)
* Used for: Auth handshakes, fetching chat history (Cold Data), posting comments.
* Standard: RESTful API design.

### B. Asynchronous (WebSockets & Pub/Sub)
* **Real-Time Chat:**
    * Client <-> Server: WebSockets.
    * Server <-> Server (Scaling): Redis Pub/Sub (to broadcast messages if we scale replicas).
* **Notifications (Internal):**
    * *Event-Driven:* When a comment is saved, emit `eventEmitter.emit('comment.created')`.
    * *Listener:* A separate module listens to write to the Notification Table (Decoupled).